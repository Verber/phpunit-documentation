<?xml version="1.0" encoding="utf-8" ?>

<chapter id="test-doubles">
  <title>Тестовые дубли</title>

  <para>
    Жерар Месзарос (Gerard Meszaros) представил новыую идею тестовых дублей в
    <xref linkend="Meszaros2007" /> следующим образом:
  </para>

  <blockquote>
    <attribution>Жерар Месзарос (Gerard Meszaros)</attribution>
    <para>
      <indexterm><primary>Испытываемая система</primary></indexterm>

      Иногда очень сложно протестировать испытываемую систему, потому
      что она зависит от других компонентов, которые нельзя использовать в
      тестовом окружении. Это происходит из-за того, что они недоступны, они не
      вернут нужный результат для теста, или вызов этих компонент повлечёт за
      собой нежелательные побочные эффекты. В других случаях наша стратегия
      тестирования требует большего контроля и видения того что происходит внутри
      системы.
    </para>

    <para>
      <indexterm><primary>Зависимые компоненты</primary></indexterm>
      <indexterm><primary>Тестовые дубли</primary></indexterm>

      Когда мы пишем тест в котором не можем (или не хотим) использовать
      реальные зависимости, мы можем заменить их тестовыми дублями. Тестовые
      дубли не должны вести себя в точности как реальные компоненты; они
      должны предоставлять тот же API, который предоставляет и реальный
      компонент, так, чтобы тестируемая система думала что они реальны!
    </para>
  </blockquote>

  <para>
    Метод <literal>getMock($className)</literal>, предоставляемый в PHPUnit
    может быть использован в тесте для генерации объекта, который ведёт себя как
    тестовый дубль для указанного класса. Этот объект-дубль может быть
    использован в любом месте кода, где ожидается объект оригинального класса.
  </para>

  <para>
    По умолчанию все методы оригинального класса заменяются методами-пустышками,
    которые возвращают <literal>NULL</literal> (не вызывая оригинальных методов).
    Используя метод <literal>will($this->returnValue())</literal>, например,
    можно настроить эти методы-пустышки таким образом, чтоб они возвращали
    заданное значение.
  </para>

  <note>
    <title>Ограничения</title>

    <para>
      Обратите внимание, что для <literal>final</literal>, <literal>private</literal>
      и <literal>static</literal> методов, нельзя сделать заглушку (stub) и мок (mock).
      Они игнорируются функциональностью PHPUnit по созданию тестовых дублей и
      сохраняют изначальное поведение.
    </para>
  </note>

  <section id="test-doubles.stubs">
    <title>Заглушки (Stubs)</title>

    <para>
      <indexterm><primary>Заглушка (Stub)</primary></indexterm>

      Практика замены объекта тестовым дублем, который (опционально) возвращает
      заданные значения называется <emphasis>заглушением (stubbing)</emphasis>.
      Можно использовать <emphasis>заглушку (stub)</emphasis> для того чтобы:
      "заменить исходный компонент от которого зависит тестируемая система таким
      образом, что тест будет иметь возможность контролировать тестируемую систему
      изнутри. Это позволяет заставить тестируемую систему выполнить действия,
      которые она не выполнила бы в обычных условиях."
    </para>

    <para>
      <indexterm><primary>Текучий интерфейс</primary></indexterm>

      <xref linkend="test-doubles.stubs.examples.StubTest.php" /> показывает как
      сделать заглушку метода и задать возвращаемое значение. Первым использован
      метод <literal>getMock()</literal>, предоставляемый классом
      <literal>PHPUnit_Framework_TestCase</literal>, для создания заглушки класса
      <literal>SomeClass</literal>
      (<xref linkend="test-doubles.stubs.examples.SomeClass.php" />), который
      выглядит так же как и оригинальный объект. Затем используется
      <ulink url="http://martinfowler.com/bliki/FluentInterface.html">текучий интерфейс</ulink>,
      предоставляемый PHPUnit для указания поведения заглушки. В конечном счёте не
      нужно создавать несколько временных объектов и соединять их после. Это
      приводит к более читабельному "текучему" коду.
    </para>

    <example id="test-doubles.stubs.examples.SomeClass.php">
      <title>Класс, заглушку которого мы хотим создать</title>
      <programlisting><![CDATA[<?php
class SomeClass
{
    public function doSomething()
    {
        // Do something.
    }
}
?>]]></programlisting>
    </example>

    <example id="test-doubles.stubs.examples.StubTest.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValue()</primary></indexterm>
      <title>Заглушка метода для возвращения фиксированного значения</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnValue('foo'));

        // Вызов $stub->doSomething() теперь вернет
        // 'foo'.
        $this->assertEquals('foo', $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      "За кулисами" PHPUnit автоматически создаёт новый PHP класс, который,
      после использования метода <literal>getMock()</literal>,
      повторяет заданное поведение. Созданный тестовый дубль можно настроить с
      помощью необязательных аргументов метода <literal>getMock()</literal>.
    </para>

    <itemizedlist>
      <listitem><para>По умолчанию все методы заданного класса заменяются дублями, которые возвращают значение <literal>NULL</literal>, если не задано другое значение, например, с помощью метода <literal>will($this->returnValue())</literal>.</para></listitem>
      <listitem><para>Когда задан второй (необязательный) параметр, заменяются только те методы тестового дубля, которые присутствуют в массиве. Поведение других методов не изменяется.</para></listitem>
      <listitem><para>Третий (необязательный) параметр может содержать массив аргументов, передаваемых в конструктор оригинального класса (который не заменяется методом-пустышкой по умолчанию).</para></listitem>
      <listitem><para>Четвертый (необязательный) параметр указывает имя класса для создаваемого тестового дубля.</para></listitem>
      <listitem><para>Пятый (необязательный) параметр указывает на то, использовать конструктор исходного класса или нет.</para></listitem>
      <listitem><para>Шестой (необязательный) параметр используется для указания использования метода клонирования исходного класса или нет.</para></listitem>
      <listitem><para>Седьмой (необязательный) параметр может запретить использование <literal>__autoload()</literal> во время создания тестового дубля.</para></listitem>
    </itemizedlist>

    <para>
      Для настройки создаваемого дубля также можно использовать Mock Builder API .
      <xref linkend="test-doubles.stubs.examples.StubTest2.php"/> показывает
      пример использования. Ниже приведён список методов, которые могут быть
      использованы:
    </para>

    <itemizedlist>
      <listitem><para><literal>setMethods(array $methods)</literal> вызывается объектом Mock Builder для указания того, какие методы будут заменены в дубле. Поведение других методов не затрагивается.</para></listitem>
      <listitem><para><literal>setConstructorArgs(array $args)</literal> вызывается для указания массива параметров, передаваемых в конструктор исходного класса (который по умолчанию не заменяется методом-пустышкой).</para></listitem>
      <listitem><para><literal>setMockClassName($name)</literal> вызывается для указания имени класса создаваемого класса дубля.</para></listitem>
      <listitem><para><literal>disableOriginalConstructor()</literal> вызывается для отмены использования конструктора исходного  класса.</para></listitem>
      <listitem><para><literal>disableOriginalClone()</literal> вызывается для отмены вызова оригинального метода клонирования.</para></listitem>
      <listitem><para><literal>disableAutoload()</literal> вызывается для отмены использования <literal>__autoload()</literal> во время создания дубля класса.</para></listitem>
    </itemizedlist>

    <example id="test-doubles.stubs.examples.StubTest2.php">
      <indexterm><primary>getMockBuilder()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValue()</primary></indexterm>
      <title>Использование Mock Builder API для настройки создаваемого класса дубля</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMockBuilder('SomeClass')
                     ->disableOriginalConstructor()
                     ->getMock();

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnValue('foo'));

        // Вызов $stub->doSomething() теперь вернет
        // 'foo'.
        $this->assertEquals('foo', $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      Иногда необходимо вернуть (неизмененный) аргумент метода в заглушке.
      <xref linkend="test-doubles.stubs.examples.StubTest3.php"/> показывает как
      достичь этого, используя <literal>returnArgument()</literal> вместо
      <literal>returnValue()</literal>.
    </para>

    <example id="test-doubles.stubs.examples.StubTest3.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnArgument()</primary></indexterm>
      <title>Стаб метода для возврата одного из аргументов</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnArgumentStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnArgument(0));

        // $stub->doSomething('foo') вернёт 'foo'
        $this->assertEquals('foo', $stub->doSomething('foo'));

        // $stub->doSomething('bar') вернёт 'bar'
        $this->assertEquals('bar', $stub->doSomething('bar'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Когда тестируется текучий интерфейс, будет полезным если заглушка вернёт
      ссылку на себя. <xref linkend="test-doubles.stubs.examples.StubTest4.php"/>
      показывает как использовать <literal>returnSelf()</literal> для того чтобы
      достичь этого.
    </para>

    <example id="test-doubles.stubs.examples.StubTest4.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnSelf()</primary></indexterm>
      <title>Заглушка метода для возврата ссылки на себя</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnSelf()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnSelf());

        // $stub->doSomething() возвращает $stub
        $this->assertSame($stub, $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>

    <para>
      Иногда нужно чтоб заглушка метода возвращала разные значения в зависимости
      от предустановленного списка параметров. Для этого можно использовать
      метод <literal>returnValueMap()</literal> для создания списка, который
      ассоциирует аргументы с соответствующими значениями. Для примера см.
      <xref linkend="test-doubles.stubs.examples.StubTest5.php"/>
    </para>

    <example id="test-doubles.stubs.examples.StubTest5.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnValueMap()</primary></indexterm>
      <title>Заглушка метода для возврата значений из списка в соответствии с
        аргументами</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnValueMapStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Создание списка агрументов и соответствующих значений.
        $map = array(
          array('a', 'b', 'c', 'd'),
          array('e', 'f', 'g', 'h')
        );

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnValueMap($map));

        // $stub->doSomething() возвращает значения в соответствии с
        // переданными аргументами.
        $this->assertEquals('d', $stub->doSomething('a', 'b', 'c'));
        $this->assertEquals('h', $stub->doSomething('e', 'f', 'g'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Если заглушка должна возвращать вычисляемое значение вместо фиксированного
      (см. <literal>returnValue()</literal>) или (неизмененного) аргумента
      (см. <literal>returnArgument()</literal>), можно использовать метод
      <literal>returnCallback()</literal> для того чтобы посчитать возвращаемое
      значение в коллбеке. Для примера см.
      <xref linkend="test-doubles.stubs.examples.StubTest6.php"/>.
    </para>

    <example id="test-doubles.stubs.examples.StubTest6.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>returnCallback()</primary></indexterm>
      <title>Заглушка метода для возврата значения из коллбэк функции</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testReturnCallbackStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->returnCallback('str_rot13'));

        // $stub->doSomething($argument) возвращает результат str_rot13($argument)
        $this->assertEquals('fbzrguvat', $stub->doSomething('something'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Иногда проще задать список значений, которые возвращает заглушка при
      повторных вызовах. Для этого можно использовать метод
      <literal>onConsecutiveCalls()</literal>. Для примера см.
      <xref linkend="test-doubles.stubs.examples.StubTest7.php"/>.
    </para>

    <example id="test-doubles.stubs.examples.StubTest7.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>onConsecutiveCalls()</primary></indexterm>
      <title>Заглушка метода для возврата заданных значений в определенном
        порядке</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testOnConsecutiveCallsStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->onConsecutiveCalls(2, 3, 5, 7));

        // $stub->doSomething() возвращает пределенное значение при каждом
        // следующем вызове
        $this->assertEquals(2, $stub->doSomething());
        $this->assertEquals(3, $stub->doSomething());
        $this->assertEquals(5, $stub->doSomething());
    }
}
?>]]></programlisting>
    </example>


    <para>
      Вместо возврата значения метод может выкинуть исключение.
      <xref linkend="test-doubles.stubs.examples.StubTest8.php"/> показывает
      пример использования метода <literal>throwException()</literal> для этих
      целей.
    </para>

    <example id="test-doubles.stubs.examples.StubTest8.php">
      <indexterm><primary>getMock()</primary></indexterm>
      <indexterm><primary>expects()</primary></indexterm>
      <indexterm><primary>method()</primary></indexterm>
      <indexterm><primary>will()</primary></indexterm>
      <indexterm><primary>throwException()</primary></indexterm>
      <title>Заглушка, которая выкидывает исключение</title>
      <programlisting><![CDATA[<?php
require_once 'SomeClass.php';

class StubTest extends PHPUnit_Framework_TestCase
{
    public function testThrowExceptionStub()
    {
        // Создание заглушки класса SomeClass.
        $stub = $this->getMock('SomeClass');

        // Настройка заглушки.
        $stub->expects($this->any())
             ->method('doSomething')
             ->will($this->throwException(new Exception));

        // $stub->doSomething() выкидывает Exception
        $stub->doSomething();
    }
}
?>]]></programlisting>
    </example>

    <para>
      Можно написать заглушку без использования <literal>getMock($className)</literal>
      и улучшить дизайн таким образом. Обычно широко используемые ресурсы
      доступны из одного и того же места, поэтому будет довольно просто заменить
      ресурс его заглушкой. Например, вместо того чтобы вызывать базу данных из
      разных мест, можно иметь один объект класса <literal>Database</literal>.
      Затем, создать заглушку <literal>IDatabase</literal> и использовать
      ее в тестах. Также можно создать опцию пробега теста с заглушкой и без нее,
      таким образом вы сможете тестировать все компоненты независимо в юнит
      тестах, и провести интеграционные тесты с использованием реальной
      базы данных.
    </para>

    <para>
      Функционал, для которого нужна заглушка стремится к внутренней связанности
      в одном объекте. Предоставляя единую функциональность в одном объекте, вы,
      тем временем уменьшаете связанность всей системы вцелом.
      <!--Functionality that needs to be stubbed out tends to cluster in the same
      object, improving cohesion. By presenting the functionality with a
      single, coherent interface you reduce the coupling with the rest of the
      system. -->
    </para>
  </section>

  <section id="test-doubles.mock-objects">
    <title>Моки (mock) объектов</title>

    <para>
      Методика замены объекта тестовым дублем, который подтверждает ожидания,
      например, утверждение того, что метод был вызван, называется
      <emphasis>моками (mocking)</emphasis>.
    </para>

    <para>
      <indexterm><primary>Мок объект</primary></indexterm>

      Можно использовать <emphasis>мок объект</emphasis> "как наблюдателя,
      который используется, для подтверждения косвенных выводов данных
      тестируемой системы в то время как она выполняется. Обычно, моки включают
      в себя функциональность заглушек, в том, что они должны возвращать значения
      в тестируемую систему, если она ещё не провалила тест. Но упор делается на
      косвенных выводах информации. Поэтому мок объекты это больше чем заглушка
      плюс утверждение состояния - это фундаментально другой метод тестирования".
    </para>

    <para>
      Например, предположим, что необходимо протестировать что верный метод
      <literal>update()</literal> из примера вызывается в объекте, обозреваемом
      другим объектом. <xref linkend="test-doubles.mock-objects.examples.SUT.php"/>
      показывает код для классов <literal>Subject</literal> и <literal>Observer</literal>,
      которые являются частью тестируемой системы.
    </para>

    <example id="test-doubles.mock-objects.examples.SUT.php">
      <title>Классы Subject и Observer из части тестируемой системы</title>
      <programlisting><![CDATA[<?php
class Subject
{
    protected $observers = array();

    public function attach(Observer $observer)
    {
        $this->observers[] = $observer;
    }

    public function doSomething()
    {
        // Что-то происходит.
        // ...

        // Notify observers that we did something.
        $this->notify('something');
    }

    public function doSomethingBad()
    {
        foreach ($this->observers as $observer) {
            $observer->reportError(42, 'Something bad happened', $this);
        }
    }

    protected function notify($argument)
    {
        foreach ($this->observers as $observer) {
            $observer->update($argument);
        }
    }

    // Другие методы.
}

class Observer
{
    public function update($argument)
    {
        // Сделать что-то.
    }

    public function reportError($errorCode, $errorMessage, Subject $subject)
    {
        // Сделать что-то
    }

    // Другие методы.
}
?>]]></programlisting>
    </example>

    <para>
      <indexterm><primary>Мок объект</primary></indexterm>

      <xref linkend="test-doubles.mock-objects.examples.SubjectTest.php" />
      показывает как использовать моки для тестирования взаимодействия объектов
      <literal>Subject</literal> и <literal>Observer</literal>.
    </para>

    <para>
      Сперва используется метод <literal>getMock()</literal>, предоставляемый
      классом <literal>PHPUnit_Framework_TestCase</literal>, для создания мока
      класса <literal>Observer</literal>. Так как во втором (необязательном)
      параметре метода <literal>getMock()</literal> передаётся массив,
      на реализацию мока будет заменён только метод <literal>update()</literal>
      из класса <literal>Observer</literal>.
    </para>

    <example id="test-doubles.mock-objects.examples.SubjectTest.php">
      <title>Тестирование того что метод будет вызван один раз и будут переданы указанные параметры</title>
      <programlisting><![CDATA[<?php
class SubjectTest extends PHPUnit_Framework_TestCase
{
    public function testObserversAreUpdated()
    {
        // Создает мок класса Observer,
        // будет заменен только метод update().
        $observer = $this->getMock('Observer', array('update'));

        // Настроить что ожидается что метод update()
        // будет вызван один раз и будет передан аргумент 'something'
        $observer->expects($this->once())
                 ->method('update')
                 ->with($this->equalTo('something'));

        // Создать экземпляр класса Subject и прикрепить мок класса
        // Observer к нему.
        $subject = new Subject;
        $subject->attach($observer);

        // Вызвать метод doSomething() объекта $subject,
        // который должен вызвать мок метода update() из мока класса
        // Observer с параметром 'something'.
        $subject->doSomething();
    }
}
?>]]></programlisting>
    </example>

    <para>
      Метод <literal>with()</literal> принимает любое количество аргументов,
      соответствующих аргументам метода мока. Можно настроить более продвинутые
      ограничения, нежели обычное совпадения. Например,
      <literal>$this->greaterThan(0)</literal> указывает что тест ожидает что
      аргумент мока вызовется с числом, большим нуля.
    </para>

    <example id="test-doubles.mock-objects.examples.MultiParameterTest.php">
      <title>Тестирование того что мок метод будет вызван с определенным
        количеством аргументов, ограниченых разными способами</title>
      <programlisting><![CDATA[<?php
class SubjectTest extends PHPUnit_Framework_TestCase
{
    public function testErrorReported()
    {
        // Создаёт мок класса Observer, мок будет реализован
        // только для метода reportError()
        $observer = $this->getMock('Observer', array('reportError'));

        $observer->expects($this->once())
                 ->method('reportError')
                 ->with($this->greaterThan(0),
                        $this->stringContains('Something'),
                        $this->anything());

        $subject = new Subject;
        $subject->attach($observer);

        // Вызов метод doSomethingBad() должен вызвать метод reportError()
        $subject->doSomethingBad();
    }
}
?>]]></programlisting>
    </example>

    <para>
      <xref linkend="writing-tests-for-phpunit.assertions.assertThat.tables.constraints"/>
      показывает все ограничения, которые можно наложить на аргументы метода мока и
      <xref linkend="test-doubles.mock-objects.tables.matchers"/>
      показывает методы определяющие совпадения, предназначеные для определения
      количества вызовов.
    </para>

    <table id="test-doubles.mock-objects.tables.matchers">
      <title>Методы совпадения</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
        <thead>
          <row>
            <entry>Методы совпадения</entry>
            <entry>Описание</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_AnyInvokedCount any()</literal></entry>
            <entry>Возвращает метод соответствия (matcher), который срабатывает при любом количестве вызовов.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount never()</literal></entry>
            <entry>Возвращает метод соответствия (matcher), который проверяет что метод никогда не был вызван.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedAtLeastOnce atLeastOnce()</literal></entry>
            <entry>Возвращает метод соответствия (matcher), который проверяет что метод был вызван хотя-бы один раз.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount once()</literal></entry>
            <entry>Возвращает метод соответствия (matcher), который проверяет что метод был вызван только один раз.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedCount exactly(int $count)</literal></entry>
            <entry>Возвращает метод соответствия (matcher), который проверяет что метод был вызван <literal>$count</literal> раз.</entry>
          </row>
          <row>
            <entry><literal>PHPUnit_Framework_MockObject_Matcher_InvokedAtIndex at(int $index)</literal></entry>
            <entry>Возвращает метод соответствия (matcher), который проверяет дальнейшие условия после достижения <literal>$index</literal> вызовов.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>
      <indexterm><primary>getMockForAbstractClass()</primary></indexterm>

      Метод <literal>getMockForAbstractClass()</literal> возвращает объект мока
      для абстрактного класса. Все абстрактные методы класса будут пустышками.
      Это позволяет протестировать реализованные методы класса.
    </para>

    <example id="test-doubles.mock-objects.examples.AbstractClassTest.php">
      <title>Тестирование реализованых методов абстрактного класса</title>
      <programlisting><![CDATA[<?php
abstract class AbstractClass
{
    public function concreteMethod()
    {
        return $this->abstractMethod();
    }

    public abstract function abstractMethod();
}

class AbstractClassTest extends PHPUnit_Framework_TestCase
{
    public function testConcreteMethod()
    {
        $stub = $this->getMockForAbstractClass('AbstractClass');
        $stub->expects($this->any())
             ->method('abstractMethod')
             ->will($this->returnValue(TRUE));

        $this->assertTrue($stub->concreteMethod());
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="test-doubles.stubbing-and-mocking-web-services">
    <title>Заглушки и моки для веб сервисов</title>

    <para>
      <indexterm><primary>getMockFromWsdl()</primary></indexterm>

      Когда в приложении есть взаимодействие с внешними веб сервисами -
      необходимо тестировать систему без обращения к ним. Чтобы сделать
      реализацию заглушек и моков простой, используется метод
      <literal>getMockFromWsdl()</literal>. Он используется таким же способом,
      как и <literal>getMock()</literal> (см. выше). Единственное отличие
      состоит в том, что <literal>getMockFromWsdl()</literal> возвращает
      заглушку или мок опираясь на описание WSDL, когда <literal>getMock()</literal>
      возвращает заглушку или мок, опираясь на код PHP класса или интерфейса.
    </para>

    <para>
      <xref linkend="test-doubles.stubbing-and-mocking-web-services.examples.GoogleTest.php"/>
      показывает как <literal>getMockFromWsdl()</literal> может быть использован
      для создания заглушки сервиса описанном в <filename>GoogleSearch.wsdl</filename>.
    </para>

    <example id="test-doubles.stubbing-and-mocking-web-services.examples.GoogleTest.php">
      <title>Заглушка для веб сервиса</title>
      <programlisting><![CDATA[<?php
class GoogleTest extends PHPUnit_Framework_TestCase
{
    public function testSearch()
    {
        $googleSearch = $this->getMockFromWsdl(
          'GoogleSearch.wsdl', 'GoogleSearch'
        );

        $directoryCategory = new StdClass;
        $directoryCategory->fullViewableName = '';
        $directoryCategory->specialEncoding = '';

        $element = new StdClass;
        $element->summary = '';
        $element->URL = 'http://www.phpunit.de/';
        $element->snippet = '...';
        $element->title = '<b>PHPUnit</b>';
        $element->cachedSize = '11k';
        $element->relatedInformationPresent = TRUE;
        $element->hostName = 'www.phpunit.de';
        $element->directoryCategory = $directoryCategory;
        $element->directoryTitle = '';

        $result = new StdClass;
        $result->documentFiltering = FALSE;
        $result->searchComments = '';
        $result->estimatedTotalResultsCount = 378000;
        $result->estimateIsExact = FALSE;
        $result->resultElements = array($element);
        $result->searchQuery = 'PHPUnit';
        $result->startIndex = 1;
        $result->endIndex = 1;
        $result->searchTips = '';
        $result->directoryCategories = array();
        $result->searchTime = 0.248822;

        $googleSearch->expects($this->any())
                     ->method('doGoogleSearch')
                     ->will($this->returnValue($result));

        /**
         * $googleSearch->doGoogleSearch() вернет заглушку и
         * метод веб сервиса doGoogleSearch() не будет вызван.
         */
        $this->assertEquals(
          $result,
          $googleSearch->doGoogleSearch(
            '00000000000000000000000000000000',
            'PHPUnit',
            0,
            1,
            FALSE,
            '',
            FALSE,
            '',
            '',
            ''
          )
        );
    }
}
?>]]></programlisting>
    </example>
  </section>

  <section id="test-doubles.mocking-the-filesystem">
    <title>Моки для файловой системы</title>

    <para>
      <ulink url="http://code.google.com/p/bovigo/wiki/vfsStream">vfsStream</ulink>
      - это <ulink url="http://ru2.php.net/streams">обёртка потока (stream
      wrapper)</ulink> для создания
      <ulink url="http://ru.wikipedia.org/wiki/Virtual_file_system">виртуальной
      файловой системы</ulink>, которая может быть использована в юнит тестах
      для файловой системы.
    </para>

    <para>
      Для того чтобы установить vfsStream, необходимо использовать PEAR канал
      (<systemitem role="URL">pear.php-tools.net</systemitem>).
      Канал необходимо зарегистрировать в локальном окружении PEAR:
    </para>

    <screen><userinput>pear channel-discover pear.php-tools.net</userinput></screen>

    <para>
      Это необходимо выполнить только один раз. А затем можно использовать PEAR
      для установки vfsStream:
    </para>

    <screen><userinput>pear install pat/vfsStream-beta</userinput></screen>

    <para>
      <xref linkend="test-doubles.mocking-the-filesystem.examples.Example.php"/>
      показывает пример класса, который взаимодействует с файловой системой. <!-- Ваш КО -->
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.Example.php">
      <title>Класс, который взаимодействует с файловой системой</title>
      <programlisting><![CDATA[<?php
class Example
{
    protected $id;
    protected $directory;

    public function __construct($id)
    {
        $this->id = $id;
    }

    public function setDirectory($directory)
    {
        $this->directory = $directory . DIRECTORY_SEPARATOR . $this->id;

        if (!file_exists($this->directory)) {
            mkdir($this->directory, 0700, TRUE);
        }
    }
}?>]]></programlisting>
    </example>

    <para>
      Без использования виртуальной файловой системы, такой как vfsStream,
      нельзя протестировать метод <literal>setDirectory()</literal> без
      изоляции от внешних факторов (см. <xref
      linkend="test-doubles.mocking-the-filesystem.examples.ExampleTest.php"/>).
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.ExampleTest.php">
      <title>Тестирование класса, который взаимодействует с файловой системой</title>
      <programlisting><![CDATA[<?php
require_once 'Example.php';

class ExampleTest extends PHPUnit_Framework_TestCase
{
    protected function setUp()
    {
        if (file_exists(dirname(__FILE__) . '/id')) {
            rmdir(dirname(__FILE__) . '/id');
        }
    }

    public function testDirectoryIsCreated()
    {
        $example = new Example('id');
        $this->assertFalse(file_exists(dirname(__FILE__) . '/id'));

        $example->setDirectory(dirname(__FILE__));
        $this->assertTrue(file_exists(dirname(__FILE__) . '/id'));
    }

    protected function tearDown()
    {
        if (file_exists(dirname(__FILE__) . '/id')) {
            rmdir(dirname(__FILE__) . '/id');
        }
    }
}
?>]]></programlisting>
    </example>

    <para>
      Подход, описаный выше, имеет несколько недостатков:
    </para>

    <itemizedlist>
      <listitem><para>Как и с любым внешним ресурсом, файловая система может быть недоступна в какой-либо промежуток времени. Это может дать случайные падения тестов. (Вообще-то эти ошибки тоже надо тестировать в этом кейсе, но VFS бывает полезной при тестировании "идеальной ФС" которая стабильна, или тесты на ошибки были сделаны где-то в другом месте (прим. пер.)</para></listitem>
      <listitem><para>В методах <literal>setUp()</literal> и <literal>tearDown()</literal> необходимо удостоверится, что директория не существует до и после таеста.</para></listitem>
      <listitem><para>Если выполнение теста прерывается до выполнения метода <literal>tearDown()</literal> - директория может остаться на файловой системе.</para></listitem>
    </itemizedlist>

    <para>
      <xref linkend="test-doubles.mocking-the-filesystem.examples.ExampleTest2.php"/>
      показывает пример использования vfsStream для мока файловой системы во
      время тестирования класса, взаимодействующего с файловой системой.
    </para>

    <example id="test-doubles.mocking-the-filesystem.examples.ExampleTest2.php">
      <title>Мок файловой системы в классе, который взаимодействует с ней</title>
      <programlisting><![CDATA[<?php
require_once 'vfsStream/vfsStream.php';
require_once 'Example.php';

class ExampleTest extends PHPUnit_Framework_TestCase
{
    public function setUp()
    {
        vfsStreamWrapper::register();
        vfsStreamWrapper::setRoot(new vfsStreamDirectory('exampleDir'));
    }

    public function testDirectoryIsCreated()
    {
        $example = new Example('id');
        $this->assertFalse(vfsStreamWrapper::getRoot()->hasChild('id'));

        $example->setDirectory(vfsStream::url('exampleDir'));
        $this->assertTrue(vfsStreamWrapper::getRoot()->hasChild('id'));
    }
}
?>]]></programlisting>
    </example>

    <para>
      Подход, описанный выше имеет несколько плюсов:
    </para>

    <itemizedlist>
      <listitem><para>Тест получается более кратким.</para></listitem>
      <listitem><para>vfsStream дает разработчику полный контроль над поведением и окружением файловой системы.</para></listitem>
      <listitem><para>Так как операции над файловой системой в действительности не взаимодействуют с ней, то больше нет необходимости в операции очистки в методе <literal>tearDown()</literal>.</para></listitem>
    </itemizedlist>
  </section>
</chapter>
