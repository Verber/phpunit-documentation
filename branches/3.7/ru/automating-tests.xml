<?xml version="1.0" encoding="utf-8" ?>

<chapter id="automating-tests">
  <title>Автоматизация Тестирования</title>

  <para>
    Даже хорошие программисты ошибаются. Разница между хорошим и плохим
    программистом в том, что хороший программист использует тесты, чтобы
    обнаружить свои ошибки как можно раньше. Чем раньше вы проверите свой код
    на наличие ошибки тем больше ваши шансы найти её и тем меньше будет стоить
    её поиск и исправление. Это объясняет почему тестирование становится большой
    проблемой если его откладывать до релиза. Большинство ошибок не будут найдены
    совсем, а цена исправления тех, которые были пойманы, будет так высока, что вам
    придётся отобрать (и исправить) только некоторые из них, потому что вы просто
    не сможете себе позволить исправить их все.
  </para>

  <para>
    <indexterm><primary>юнит-тест</primary></indexterm>

    Тестирование с помощью PHPUnit не слишком отличается от того, что
    вы уже, должно быть, делаете. Это всего лишь другой способ делать это.
    Разница между <emphasis>тестированием</emphasis>, то есть, проверкой того,
    что ваша програма ведёт себя так как ожидалось, и <emphasis>выполнением набора
    тестов</emphasis>, выполняемых фрагментов кода, которые автоматически проверяют
    правильность частей (модулей или юнитов) ПО. Эти исполняемые фрагменты кода и
    есть юнит-тесты.
  </para>

  <para>
    В этой главе мы перейдём от простого тестового кода основанного на
    <literal>print</literal>-ах к полностью автоматизированому тесту. Представьте себе
    что вас попросили протестировать встроенный в PHP <literal>array</literal>.
    Одна из частей функциональности, которую нужно протестировать - функция
    <literal>count()</literal>. Для только что созданного массива мы ожидаем что функция
    <literal>count()</literal> вернёт <literal>0</literal>. После добавления одного элемента
    <literal>count()</literal> должна вернуть <literal>1</literal>.
    <xref linkend="automating-tests.examples.array-test.php" /> демонстрирует то что мы
    хотим протестировать.
  </para>

  <example id="automating-tests.examples.array-test.php">
    <title>Тестирование работы с массивами</title>
    <programlisting><![CDATA[<?php
$fixture = array();
// ожидается, что $fixture будет пустой.

$fixture[] = 'element';
// ожидается, что $fixture содержит один элемент
?>]]></programlisting>
  </example>

  <para>
    Самый простой способ проверить что мы получаем в результате то что
    мы ожидали - это распечатать результат <literal>count()</literal> до
    и после добавления элемента (см. <xref linkend="automating-tests.examples.array-test2.php" />).
    Если мы получим <literal>0</literal> а затем <literal>1</literal>,
    <literal>array</literal> и <literal>count()</literal> работают так как ожидалось.
  </para>

  <example id="automating-tests.examples.array-test2.php">
    <title>Используем print для проверки операций с массивами</title>
    <programlisting><![CDATA[<?php
$fixture = array();
print count($fixture) . "\n";

$fixture[] = 'element';
print count($fixture) . "\n";
?>]]></programlisting>
    <screen>0
1</screen>
  </example>

  <para>
    Now, we would like to move from tests that require manual interpretation
    to tests that can run automatically. In
    <xref linkend="automating-tests.examples.array-test3.php" />, we write
    the comparison of the expected and actual values into the test code and
    print <literal>ok</literal> if the values are equal. If we ever see a
    <literal>not ok</literal> message, we know something is wrong.
  </para>

  <example id="automating-tests.examples.array-test3.php">
    <title>Comparing expected and actual values to test array operations</title>
    <programlisting><![CDATA[<?php
$fixture = array();
print count($fixture) == 0 ? "ok\n" : "not ok\n";

$fixture[] = 'element';
print count($fixture) == 1 ? "ok\n" : "not ok\n";
?>]]></programlisting>
    <screen>ok
ok</screen>
  </example>

  <para>
    <indexterm><primary>Assertions</primary></indexterm>

    We now factor out the comparison of expected and actual values into a
    function that raises an Exception when there is a discrepancy
    (<xref linkend="automating-tests.examples.array-test4.php" />). This
    gives us two benefits: the writing of tests becomes easier and we only
    get output when something is wrong.
  </para>

  <example id="automating-tests.examples.array-test4.php">
    <title>Using an assertion function to test array operations</title>
    <programlisting><![CDATA[<?php
$fixture = array();
assertTrue(count($fixture) == 0);

$fixture[] = 'element';
assertTrue(count($fixture) == 1);

function assertTrue($condition)
{
    if (!$condition) {
        throw new Exception('Assertion failed.');
    }
}
?>]]></programlisting>
  </example>

  <para>
    <indexterm><primary>Automated Test</primary></indexterm>

    The test is now completely automated. Instead of just
    <emphasis>testing</emphasis> as we did with our first version,
    with this version we have an <emphasis>automated test</emphasis>.
  </para>

  <para>
    The goal of using automated tests is to make fewer mistakes. While your
    code will still not be perfect, even with excellent tests, you will
    likely see a dramatic reduction in defects once you start automating
    tests. Automated tests give you justified confidence in your code. You
    can use this confidence to take more daring leaps in design
    (Refactoring), get along with your teammates better (Cross-Team Tests),
    improve relations with your customers, and go home every night with
    proof that the system is better now than it was this morning because of
    your efforts.
  </para>
</chapter>
